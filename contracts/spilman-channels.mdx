---
title: "Spilman Channels"
description: "Build scalable payment channels on Arkade"
icon: "route"
---

<Warning>
  **Experimental Technology**

  Spilman Channels on Arkade are experimental and under active development.\
  The examples and scripts presented here are for research and proof-of-concept use only.\
  Do not deploy in production environments.
</Warning>

<Card title="Spilman Channel Example" icon="github" horizontal href="https://github.com/arkade-os/ts-sdk/blob/master/examples/spilman.js">
  Reference implementation of a virtual Spilman Channel within Arkade
</Card>

A Spilman Channel is a classic unidirectional payment channel design that allows one party (Alice) to incrementally pay another (Bob) offchain, using monotonically increasing state updates. On Arkade, Spilman Channels are implemented as virtual channels, using VTXOs and checkpoint transactions instead of onchain funding and settlement transactions.

This design enables lightweight, private, and low-cost payment streams between users while retaining Bitcoin-level security guarantees via Arkade.

## Channel Lifecycle

1. **Setup**: Alice locks funds so that either Bob can take an ever-increasing amount immediately (by holding the latest state transaction), or Alice can take everything back after a timeout (refund path).
2. **Offchain Updates**: Every payment is a new transaction that is signed by Alice and that pays more to Bob than the previous one. The transaction is not published to the Arkade server, but sent to Bob.
3. **Closing the Channel**
   - Cooperative Close: Bob can close the channel by adding his signature to the presigned transaction he received from Alice together with the corresponding checkpoint data.
   - Refund Path: If Bob is unresponsive, Alice waits for the CLTV/CSV timelock to expire and reclaims her funds via the refund path.

## Spending Paths

A virtual Spilman Channel is composed of a Taproot tree with four key spending paths:

| Path                     | Script Type   | Participants         | Description                                            |
| ------------------------ | ------------- | -------------------- | ------------------------------------------------------ |
| `updateScript`           | MultiSig      | Alice + Bob + Server | Used for cooperative offchain updates                  |
| `refundScript`           | CLTV MultiSig | Alice + Server       | Allows refund after an absolute height                 |
| `unilateralUpdateScript` | CSV MultiSig  | Alice + Bob          | Enables unilateral channel closure after a short delay |
| `unilateralRefundScript` | CSV SingleSig | Alice                | Fallback refund path after a longer delay              |

<Info>
  The timelocks are ordered such that: `unilateralUpdateDelay` \< `unilateralRefundDelay`. This ensures that Bob can always close with the latest valid state before Alice’s refund becomes valid.
</Info>

## Example Implementation

```js
import {
  SingleKey,
  Wallet,
  RestArkProvider,
  RestIndexerProvider,
  buildOffchainTx,
  VtxoScript,
  MultisigTapscript,
  CLTVMultisigTapscript,
  CSVMultisigTapscript,
  networks,
} from "../dist/esm/index.js";

// Spilman Channel construction (simplified)
const SERVER_PUBLIC_KEY = hex.decode("e35799...dbdb");
const alice = SingleKey.fromRandomBytes();
const bob = SingleKey.fromRandomBytes();

const updateScript = MultisigTapscript.encode({
  pubkeys: [await alice.xOnlyPublicKey(), await bob.xOnlyPublicKey(), SERVER_PUBLIC_KEY],
}).script;

const refundScript = CLTVMultisigTapscript.encode({
  pubkeys: [await alice.xOnlyPublicKey(), SERVER_PUBLIC_KEY],
  absoluteTimelock: BigInt(chainTip + 10),
}).script;

const unilateralUpdateScript = CSVMultisigTapscript.encode({
  pubkeys: [await alice.xOnlyPublicKey(), await bob.xOnlyPublicKey()],
  timelock: { type: "blocks", value: 100n },
}).script;

const unilateralRefundScript = CSVMultisigTapscript.encode({
  pubkeys: [await alice.xOnlyPublicKey()],
  timelock: { type: "blocks", value: 102n },
}).script;

const virtualSpilmanChannel = new VtxoScript([
  updateScript,
  refundScript,
  unilateralUpdateScript,
  unilateralRefundScript,
]);

console.log("Spilman Channel Address:", virtualSpilmanChannel.address(networks.regtest.hrp
```

### Timelock Ordering and Safety

1. CSV(unilateralUpdate)  \<  CSV(unilateralRefund)
2. CLTV(refund)                 \>  current height + Δ

This ensures:

- Updates are always possible before refunds.
- Alice cannot reclaim funds prematurely.
- Bob can safely claim his latest payment state.

## Integration with Arkade

On Arkade, these channel contracts are expressed as VTXOs. The Arkade server participates in cooperative branches only, facilitating batching and checkpoint finalization, but it cannot unilaterally spend or steal funds.

Key properties:

- Private: Updates remain offchain.
- Cheap: No onchain footprint until settlement.
- Safe: Script-level guarantees enforced by timelocks.
- Compositional: Can be nested or linked to higher-level Arkade contracts.