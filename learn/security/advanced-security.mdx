---
title: "Advanced Security"
description: "TEEs, slashing, encryption, and trust minimization"
icon: "lock-keyhole"
---

Arkade transforms "trust the operator" into "verify the operator" through multiple technical safeguards.

## Security Mechanisms

| Mechanism | What It Does | Trust Reduction |
|-----------|--------------|-----------------|
| **Arkade Signer** | Separates signing from operator control | Operator can't access keys |
| **TEE Isolation** | Hardware-protected execution | Even operator can't tamper |
| **Remote Attestation** | Proves correct code is running | Verifiable without trust |
| **E2E Encryption** | Protects user-signer communication | Operator can't censor |
| **Slashing** | Burns collateral for misbehavior | Economic penalty for fraud |

## Arkade Signer

The Arkade Signer is a separate module that holds the cosigning key for all VTXOs. It's architecturally isolated from the operator:

```
┌─────────────────┐         ┌─────────────────┐
│  User Wallet    │◄──E2E──►│  Arkade Signer  │
└────────┬────────┘         └────────┬────────┘
         │                           │
         │                           │ (key never leaves TEE)
         ▼                           │
┌─────────────────┐                  │
│ Arkade Operator │◄─────────────────┘
│ (coordination)  │   (can't access signing key)
└─────────────────┘
```

The operator handles coordination (batching, validation, broadcasting) but never touches the signing key. This separation means:

- Operator compromise doesn't expose keys
- Users communicate directly with Signer
- Signing decisions are independent of operator

## Trusted Execution Environment (TEE)

The Arkade Signer runs inside a TEE (like Intel SGX), which provides:

| Property | What It Means |
|----------|---------------|
| **Isolation** | Code runs in sealed enclave, invisible to host OS |
| **Key protection** | Signing key generated inside TEE, never exported |
| **Tamper evidence** | Any modification invalidates the enclave |
| **Attestation** | Remote proof that specific code is running |

<Info>
TEEs aren't perfect—side-channel attacks exist. But they significantly raise the bar for compromise compared to pure software solutions.
</Info>

### Remote Attestation

Users can verify the Signer is running expected code:

1. Signer produces attestation report (signed by hardware)
2. Report contains hash of running code
3. User compares hash against published open-source build
4. If match → confidence that Signer follows protocol

```typescript
// Verify Signer attestation (simplified)
const attestation = await getSignerAttestation()
const expectedHash = getExpectedCodeHash('v1.2.3')

if (attestation.codeHash === expectedHash) {
  console.log('Signer verified: running expected code')
} else {
  console.error('Attestation mismatch!')
}
```

## End-to-End Encryption

Communication between users and the Arkade Signer is encrypted:

| Without E2EE | With E2EE |
|--------------|-----------|
| Operator sees all requests | Operator sees encrypted blobs |
| Operator can censor specific txs | Operator can't identify tx content |
| User behavior exposed | User privacy preserved |

Even though the operator routes messages, they can't:
- See which addresses are transacting
- Block individual transactions
- Build surveillance profiles

## Slashing

Operators can stake Bitcoin collateral locked to the Signer's public key. If the Signer double-signs conflicting transactions:

1. User obtains cryptographic proof of double-sign
2. User presents proof to TEE
3. TEE verifies proof and signs burn transaction
4. Collateral is destroyed

```
Double-sign detected
        ▼
┌─────────────────────┐
│  Proof submitted    │
│  to TEE             │
└─────────┬───────────┘
          ▼
┌─────────────────────┐
│  TEE verifies       │
│  & signs burn tx    │
└─────────┬───────────┘
          ▼
┌─────────────────────┐
│  Collateral burned  │
│  (irreversible)     │
└─────────────────────┘
```

### Economic Security

For slashing to be effective:

```
Collateral value > Potential gain from fraud
```

If an operator stakes 1 BTC and could only profit 0.1 BTC from double-signing, fraud is economically irrational.

<Warning>
TEEs can't maintain global state perfectly—restart cycles could theoretically be exploited. Slashing ensures that even if double-signing occurs, the operator suffers losses.
</Warning>

## Layered Security

These mechanisms work together:

| Layer | Protects Against |
|-------|------------------|
| **Unilateral exit** | Total operator failure |
| **TEE isolation** | Key theft, tampering |
| **Attestation** | Malicious code |
| **E2E encryption** | Censorship, surveillance |
| **Slashing** | Double-signing attempts |

No single mechanism is foolproof, but combined they create strong guarantees.

## Next Steps

<CardGroup cols={2}>
  <Card title="Transaction Finality" icon="check-double" href="/learn/security/transaction-finality">
    Preconfirmation vs Bitcoin security
  </Card>
  <Card title="Risks & Limitations" icon="triangle-exclamation" href="/learn/security/risks-limitations">
    Known attack vectors and mitigations
  </Card>
</CardGroup>
