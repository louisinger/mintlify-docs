---
title: "Batch Swaps"
description: "How VTXOs achieve Bitcoin finality"
icon: "rotate"
---

Batch swaps let you upgrade VTXOs from preconfirmed state to full Bitcoin security without leaving Arkade.

## Why Settle?

| Reason | Problem | Batch Swap Solves It |
|--------|---------|---------------------|
| **Security** | Preconfirmed VTXOs trust the operator | New VTXOs anchored to Bitcoin |
| **Exit costs** | Deep transaction chains = expensive exit | Resets to 1-level depth |
| **Expiry** | VTXOs expire if not renewed | Fresh expiry timer |

## How It Works

You exchange old VTXOs for new ones in a single atomic operation:

```
┌─────────────────┐                    ┌─────────────────┐
│ Your Old VTXOs  │                    │ Your New VTXOs  │
│ (preconfirmed)  │ ───batch swap───▶  │ (Bitcoin final) │
│                 │                    │                 │
│ • Deep in tree  │                    │ • Fresh depth   │
│ • Near expiry   │                    │ • New expiry    │
│ • Operator trust│                    │ • Onchain anchor│
└─────────────────┘                    └─────────────────┘
```

The swap is **atomic**: either both sides complete, or neither does. You never lose custody.

## Commitment Transactions

A commitment transaction is the single onchain footprint that anchors a batch. It contains:

<div style={{ display:"flex",justifyContent:"center" }}>
<img
  className="block dark:hidden"
  src="/images/ark/commitmenttxlight.png"
  alt="Commitment transaction"
  style={{ width:"70%",height:"auto" }}
/>

</div>

<div style={{ display:"flex",justifyContent:"center" }}>
<img
  className="hidden dark:block mx-auto"
  src="/images/ark/commitmenttxdark.png"
  alt="Commitment transaction"
  style={{ width:"70%",height:"auto" }}
/>

</div>

| Output | Purpose |
|--------|---------|
| **Batch output** | Contains all participants' new VTXOs in a tree structure |
| **Connector output** | Enables atomic swap coordination via forfeit transactions |

Once confirmed on Bitcoin, all VTXOs in the batch inherit Bitcoin's security guarantees.

## Forfeit Transactions

Forfeit transactions make the swap atomic. When you participate in a batch swap, you sign a forfeit transaction that:

1. Gives the operator your old VTXO
2. **Only becomes valid** when the new commitment transaction confirms

This creates mutual dependency:
- You only forfeit old VTXOs if you receive new ones
- Operator only gets old VTXOs if they publish the commitment transaction

<Info>
Forfeit transactions also protect the operator. If you try to double-spend by broadcasting an old exit transaction after a swap, the operator broadcasts the forfeit transaction to claim those funds.
</Info>

## Step-by-Step Process

<Steps>
  <Step title="Submit Intent">
    You tell the operator which VTXOs to swap and what outputs you want:
    
    ```typescript
    // SDK handles this automatically
    await wallet.settle()
    ```
    
    Your intent includes a BIP322 ownership proof—no funds leave your control.
  </Step>
  
  <Step title="Operator Builds Batch">
    The operator collects intents from all participants and constructs:
    - New commitment transaction
    - Virtual transaction tree with everyone's new VTXOs
    - Connector outputs for atomicity
  </Step>
  
  <Step title="You Verify & Sign">
    You receive the proposed tree and verify your new VTXOs are correct. Then sign:
    - Forfeit transaction (releases old VTXOs conditionally)
    - Tree signatures (MuSig2 for your branch)
  </Step>
  
  <Step title="Operator Broadcasts">
    Once all signatures are collected, the operator broadcasts the commitment transaction to Bitcoin.
  </Step>
  
  <Step title="Confirmation">
    After Bitcoin confirms the commitment transaction:
    - Your new VTXOs are valid and spendable
    - Your old VTXOs are invalidated
    - Expiry timer resets
  </Step>
</Steps>

## SDK Usage

```typescript
// Check which VTXOs need settlement
const vtxos = await wallet.getVtxos()
const preconfirmed = vtxos.filter(v => v.virtualStatus.state === 'preconfirmed')

console.log(`${preconfirmed.length} VTXOs to settle`)

// Settle all preconfirmed VTXOs
await wallet.settle()

// Verify settlement
const balance = await wallet.getBalance()
console.log(`Settled: ${balance.settled} sats`)
```

## When to Settle

| Situation | Action |
|-----------|--------|
| Received large payment | Settle for security |
| Many chained transactions | Settle to reset depth |
| VTXO nearing expiry | Settle to renew |
| Want to reduce operator trust | Settle periodically |
| Small, frequent payments | Stay preconfirmed (faster/cheaper) |

<Tip>
A practical pattern: settle once per day or when your preconfirmed balance exceeds a threshold you're comfortable with.
</Tip>

## Delegation

Don't want to manually participate in batch swaps? [Delegate to a third party](/learn/pillars/batch-expiry#delegation-solutions) who submits intents on your behalf. You keep full control—delegates can only renew VTXOs to addresses you specify.

## Next Steps

<CardGroup cols={2}>
  <Card title="Batch Outputs" icon="box-open" href="/learn/pillars/batch-outputs">
    How VTXOs are organized in trees
  </Card>
  <Card title="Connectors" icon="link" href="/learn/pillars/connectors">
    How atomicity is enforced
  </Card>
  <Card title="Intent System" icon="gear" href="/arkd/components/intent-system">
    Technical details of intent coordination
  </Card>
  <Card title="Settlement Workflow" icon="server" href="/arkd/txs/onchain-settlement">
    Full API-level walkthrough
  </Card>
</CardGroup>
